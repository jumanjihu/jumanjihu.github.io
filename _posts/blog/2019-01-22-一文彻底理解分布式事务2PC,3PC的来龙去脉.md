# 一文彻底理解分布式事务2PC,3PC的来龙去脉

## 分布式事务

通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，而分布式事务处理的对象是全局事务。 所谓全局事务，是指分布式事务处理环境中，多个数据库可能需要共同完成一个工作，这个工作即是一个全局事务，例如，一个事务中可能更新几个不同的数据库（这些不同的数据库在不同的节点），对数据库的操作发生在系统的各处但必须全部被提交或回滚。此时一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖与全局事务相关的其它数据库的操作是否成功，如果任一数据库的任一操作失败，则参与此事务的所有数据库所做的所有操作都必须回滚。 一般情况下，某一数据库无法知道其它数据库在做什么。因此，在这个环境中，事务中间件是必需的，由它通知和协调相关数据库的提交或回滚，一般称为协调者coordinator，其他的一般称为参与者participants，而一个参与者数据库只将其自己所做的操作（可恢复）影射到全局事务中。
二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。

## 2PC-2阶段提交

### 为何需要2阶段提交
根据之前的推论我们知道分布式事务必须知道本地事务的所有执行情况才能判断是否执行，因此分为两个阶段，假设第一个阶段是执行和提交事务，
那么第二阶段则是根据各个本地事务的事务最终提交成功情况决定分布式事务是否完成，如果某个节点出现问题，反馈了非ok的情况，则必须回退事务。
由于事务提交后回退事务的代价比较高，而事务执行中回滚事务代价比较低，那么我们可以把提交与不提交事务从第一阶段移到第二阶段。因此就有了2阶段提交协议。
二阶段提交协议，即将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段，这种说法主要是从协调者的角度定义。前文可知至少有两个角色参与，事务的发起者称协调者coordinator，事务的执行者称参与者participants，提交阶段包括各个本地事务的最终提交。
### 2阶段提交协议内容
#### 阶段1：准备阶段
  
  
    1.  协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。
  
    2.  各参与者执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）。
  
    3.  如参与者执行成功，给协调者反馈YES，即可以提交；如执行失败，给协调者反馈NO，即不可提交。
  
####  阶段2：提交阶段
  
 
　　此阶段分两种情况：
  
    1. 所有参与者均反馈YES、或任何一个参与者反馈NO。所有参与者均反馈YES时，即提交事务。
    2. 任何一个参与者反馈NO时，即中断事务。
 
　　如图所示
  ![avatar](http://cxh.me/images/2014/2pc.png)
###  2PC的缺陷

    1. 同步阻塞：最大的问题即同步阻塞，即：当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
    2. 单点问题：协调者存在单点问题，如果协调者出现故障，参与者将一直处于锁定状态。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机参与者部分宕机并且所有正常未宕机参与者都处于第一阶段prepare状态，这时最坏情况下其他宕机参与者有commit或者abort状态，除非有一个宕机的参与者回复之前收到的非prepare状态才能确定是commit或者abort，协调者才能重发指令使系统一致）
    3. 脑裂(数据不一致)：在阶段2中，如果只有部分参与者完成了事务提交，也就是接收并执行了Commit请求，会导致节点数据不一致。
 
　　由于2PC存在如上同步阻塞、单点、脑裂问题，因此又出现了2PC的改进方案，即3PC。
 

## 3PC-三阶段提交协议内容
 
　　3PC，三阶段提交协议，是2PC的改进版本，与两阶段提交不同的是，三阶段提交主要是解决2PC的单点问题。

### 从2PC到3PC
我们先来推导为何需要有3阶段才能解决单点问题：

如前所述单点问题，我们知道在阶段1锁定资源执行事务时，如果协调者宕机或者超时部分参与者节点超时或者宕机，协调者恢复后可以处理，那么阶段1的下个阶段必须只要有一个参与者从宕机恢复正常的反馈就可以确定，这样就必须把prepare阶段和第一次执行事务反馈yes和no的阶段区分开来。这样改造后再加上超时机制就有了3阶段提交。

目前已经有了3阶段的雏形，我们推导对超时的处理。前文所述，我们知道在提交阶段也就是现在的第3阶段，协调者宕机可能有其他节点commit事务，而commit事务无法回退，因此我们只能规定超时自动执行commit事务与之保持一致。这样的话在最坏的情况下，协调者宕机正常，所有正常参与者节点都只是在2阶段等待指令，我们就让他们全部自动commit事务就能保持一致了。在其他情况下，有一个正常节点收到了3阶段的commit或abort指令，协调者继续恢复后发给其他参与者即可。这时如果已经发了commit指令，而某个参与者宕机后恢复正常反馈no不会导致abort，也会存在数据不一致的情况，但是没办法，总会有这样的情况，我们只能二选一。

这样就有了完整的3阶段提交.

### 3阶段提交协议内容



#### 阶段1：CanCommit

    1. 协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复。
    2. 参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO。
 
####  阶段2：PreCommit
 
　　此阶段分两种情况：
   
    1. 所有参与者均反馈YES，即执行事务预提交。
    2. 任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。
 
　　事务预提交：（所有参与者均反馈YES时）
  
    1. 协调者向所有参与者发出PreCommit请求，进入准备阶段。
    2. 参与者收到PreCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）。
    3. 各参与者向协调者反馈Ack响应或No响应，并等待最终指令。

 

　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）
  
    1. 协调者向所有参与者发出abort请求。
    2. 无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。
  

####  阶段3：do Commit
 
　　此阶段也存在两种情况：
  
    1. 所有参与者均反馈Ack响应，即执行真正的事务提交。
    2. 任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。
  
 
　　提交事务：（所有参与者均反馈Ack响应时）
  
    1. 如果协调者处于工作状态，则向所有参与者发出do Commit请求。
    2. 参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。
    3. 各参与者向协调者反馈Ack完成的消息。
    4. 协调者收到所有参与者反馈的Ack消息后，即完成事务提交。
 
　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到足够多参与者的Ack反馈时）
  
    1. 如果协调者处于工作状态，向所有参与者发出abort请求。
    2. 参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。
    3. 各参与者向协调者反馈Ack完成的消息。
    4. 协调者收到所有参与者反馈的Ack消息后，即完成事务中断。
  
  如图所示
![avatar](https://pic3.zhimg.com/v2-48edcdb98dbd2d0a11963d1c29f17d8a_r.jpg)

 
　　
 

### 3PC的优点和缺陷
 
　　优点：降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务。
 
　　缺陷：脑裂问题依然存在，即在参与者收到PreCommit请求后等待最终指令，如果此时协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。
  
## 参考资料

https://blog.csdn.net/lnho2015/article/details/78685503

https://blog.csdn.net/Hedy17/article/details/80448195

https://zhuanlan.zhihu.com/p/43881165

https://blog.csdn.net/forever_wind/article/details/37506027
