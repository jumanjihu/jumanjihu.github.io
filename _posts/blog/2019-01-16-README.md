
# Java HashMap原理精简总结

原理涉及到数据结构和算法

## 数组+链表

数据结构有个专属名称，hash表，又叫散列表。该结构就是数组+链表的形式，这样发挥了两者的优势，数组查询效率高，链表修改效率高。

链表因为hash值冲突，同一hash值的存储放到链表里。

算法简单来说就是首先通过key的hashCode在数组查找对应的节点，然后依次比较该数组下链表的key，如果key值相等则找到了value。存储同理。


![avatar](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=716256403,3942947895&fm=26&gp=0.jpg)

### key的hashcode
查看String的源码可知，通过公式s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]计算，其中s[i]表示它的第几个char，n表示String的length
，^表示幂运算。另外注意 重写Java的equals方法要重新hashCode方法，就是为了map的存储，否则该类对象作为map的key使用时
相同的key会因为hashCode的不同保存到不同的数组下，这样就不支持作为map的key值使用。

## 扩容机制
具体java的实现在存储时整个空间使用大于某个阈值会扩容2倍空间，某个链表超过阈值会转化为红黑树存储。
2倍扩容是个巧妙的设计，这样扩容前后的原节点要么在原来的位置要么在2倍的索引位置。

## 链表的存储进化
在java8中，当该节点下链表数据过多时，会变种成红黑树结构存储。

红黑树平衡要求不严格，因此插入和删除自平衡的代价小，适用于读写权衡的场景，主流语言的map数据类型一般用红黑树，比如java map里的链表在超过阈值会改造成红黑树存储。
平衡二叉树则平衡要求严格，但查找速度快，适用于频繁查的场景，主要用于数据库存储。

## 参考资料
